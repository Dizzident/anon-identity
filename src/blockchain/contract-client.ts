import { ethers, Contract, Wallet, Provider } from 'ethers';
import { BlockchainConfig, ContractAddresses } from './types';

// Import contract ABIs (these will be generated by Hardhat)
import DIDRegistryABI from '../../artifacts/contracts/DIDRegistry.sol/DIDRegistry.json';
import RevocationRegistryABI from '../../artifacts/contracts/RevocationRegistry.sol/RevocationRegistry.json';
import SchemaRegistryABI from '../../artifacts/contracts/SchemaRegistry.sol/SchemaRegistry.json';

export class ContractClient {
  private provider: Provider;
  private signer?: Wallet;
  private contracts: {
    didRegistry: Contract;
    revocationRegistry: Contract;
    schemaRegistry: Contract;
  };

  constructor(
    rpcUrlOrConfig: string | BlockchainConfig,
    privateKey?: string,
    contractAddresses?: ContractAddresses
  ) {
    // Handle both constructor signatures
    if (typeof rpcUrlOrConfig === 'string') {
      // New signature: (rpcUrl, privateKey, contractAddresses)
      this.provider = new ethers.JsonRpcProvider(rpcUrlOrConfig);
      
      if (privateKey) {
        this.signer = new ethers.Wallet(privateKey, this.provider);
      }

      if (!contractAddresses) {
        throw new Error('Contract addresses required when using RPC URL constructor');
      }

      const signerOrProvider = this.signer || this.provider;
      
      this.contracts = {
        didRegistry: new ethers.Contract(
          contractAddresses.didRegistry,
          DIDRegistryABI.abi,
          signerOrProvider
        ),
        revocationRegistry: new ethers.Contract(
          contractAddresses.revocationRegistry,
          RevocationRegistryABI.abi,
          signerOrProvider
        ),
        schemaRegistry: new ethers.Contract(
          contractAddresses.schemaRegistry,
          SchemaRegistryABI.abi,
          signerOrProvider
        ),
      };
    } else {
      // Original signature: (config)
      const config = rpcUrlOrConfig;
      this.provider = new ethers.JsonRpcProvider(config.rpcUrl);
      
      if (config.privateKey) {
        this.signer = new ethers.Wallet(config.privateKey, this.provider);
      }

      const signerOrProvider = this.signer || this.provider;
      
      this.contracts = {
        didRegistry: new ethers.Contract(
          config.contracts.didRegistry,
          DIDRegistryABI.abi,
          signerOrProvider
        ),
        revocationRegistry: new ethers.Contract(
          config.contracts.revocationRegistry,
          RevocationRegistryABI.abi,
          signerOrProvider
        ),
        schemaRegistry: new ethers.Contract(
          config.contracts.schemaRegistry,
          SchemaRegistryABI.abi,
          signerOrProvider
        ),
      };
    }
  }

  // DID Registry methods
  async registerDID(
    did: string, 
    publicKey: string, 
    documentHash: string = ''
  ): Promise<ethers.TransactionResponse> {
    if (!this.signer) {
      throw new Error('Signer required for write operations');
    }
    
    return await this.contracts.didRegistry.registerDID(did, publicKey, documentHash);
  }

  async updateDID(
    did: string, 
    newPublicKey: string, 
    documentHash: string = ''
  ): Promise<ethers.TransactionResponse> {
    if (!this.signer) {
      throw new Error('Signer required for write operations');
    }
    
    return await this.contracts.didRegistry.updateDID(did, newPublicKey, documentHash);
  }

  async deactivateDID(did: string): Promise<ethers.TransactionResponse> {
    if (!this.signer) {
      throw new Error('Signer required for write operations');
    }
    
    return await this.contracts.didRegistry.deactivateDID(did);
  }

  async transferDID(did: string, newOwner: string): Promise<ethers.TransactionResponse> {
    if (!this.signer) {
      throw new Error('Signer required for write operations');
    }
    
    return await this.contracts.didRegistry.transferDID(did, newOwner);
  }

  async resolveDID(did: string): Promise<any> {
    return await this.contracts.didRegistry.resolveDID(did);
  }

  async didExists(did: string): Promise<boolean> {
    return await this.contracts.didRegistry.didExists(did);
  }

  async getDIDsByOwner(owner: string): Promise<string[]> {
    return await this.contracts.didRegistry.getDIDsByOwner(owner);
  }

  // Revocation Registry methods
  async authorizeIssuer(issuerDID: string): Promise<ethers.TransactionResponse> {
    if (!this.signer) {
      throw new Error('Signer required for write operations');
    }
    
    return await this.contracts.revocationRegistry.authorizeIssuer(issuerDID);
  }

  async deauthorizeIssuer(issuerDID: string): Promise<ethers.TransactionResponse> {
    if (!this.signer) {
      throw new Error('Signer required for write operations');
    }
    
    return await this.contracts.revocationRegistry.deauthorizeIssuer(issuerDID);
  }

  async publishRevocationList(
    issuerDID: string,
    credentialHashes: string[],
    signature: string,
    merkleRoot: string = ethers.ZeroHash
  ): Promise<ethers.TransactionResponse> {
    if (!this.signer) {
      throw new Error('Signer required for write operations');
    }
    
    return await this.contracts.revocationRegistry.publishRevocationList(
      issuerDID,
      credentialHashes,
      signature,
      merkleRoot
    );
  }

  async revokeCredentials(
    issuerDID: string,
    credentialHashes: string[],
    signature: string
  ): Promise<ethers.TransactionResponse> {
    if (!this.signer) {
      throw new Error('Signer required for write operations');
    }
    
    return await this.contracts.revocationRegistry.revokeCredentials(
      issuerDID,
      credentialHashes,
      signature
    );
  }

  async isCredentialRevoked(issuerDID: string, credentialId: string): Promise<boolean> {
    return await this.contracts.revocationRegistry.isCredentialRevoked(issuerDID, credentialId);
  }

  async isCredentialRevokedByHash(issuerHash: string, credentialHash: string): Promise<boolean> {
    return await this.contracts.revocationRegistry.isCredentialRevokedByHash(issuerHash, credentialHash);
  }

  async getRevocationList(issuerDID: string): Promise<any> {
    return await this.contracts.revocationRegistry.getRevocationList(issuerDID);
  }

  async getRevokedCredentialCount(issuerDID: string): Promise<bigint> {
    return await this.contracts.revocationRegistry.getRevokedCredentialCount(issuerDID);
  }

  async verifyRevocationProof(
    issuerDID: string,
    credentialHash: string,
    merkleProof: string[]
  ): Promise<boolean> {
    return await this.contracts.revocationRegistry.verifyRevocationProof(
      issuerDID,
      credentialHash,
      merkleProof
    );
  }

  // Schema Registry methods
  async registerSchema(
    name: string,
    description: string,
    schemaHash: string,
    issuerDID: string,
    version: string,
    schemaType: number,
    dependencies: string[] = []
  ): Promise<ethers.TransactionResponse> {
    if (!this.signer) {
      throw new Error('Signer required for write operations');
    }
    
    return await this.contracts.schemaRegistry.registerSchema(
      name,
      description,
      schemaHash,
      issuerDID,
      version,
      schemaType,
      dependencies
    );
  }

  async updateSchema(
    schemaId: number,
    description: string,
    schemaHash: string,
    newVersion: string,
    dependencies: string[] = []
  ): Promise<ethers.TransactionResponse> {
    if (!this.signer) {
      throw new Error('Signer required for write operations');
    }
    
    return await this.contracts.schemaRegistry.updateSchema(
      schemaId,
      description,
      schemaHash,
      newVersion,
      dependencies
    );
  }

  async deactivateSchema(schemaId: number): Promise<ethers.TransactionResponse> {
    if (!this.signer) {
      throw new Error('Signer required for write operations');
    }
    
    return await this.contracts.schemaRegistry.deactivateSchema(schemaId);
  }

  async transferSchema(schemaId: number, newOwner: string): Promise<ethers.TransactionResponse> {
    if (!this.signer) {
      throw new Error('Signer required for write operations');
    }
    
    return await this.contracts.schemaRegistry.transferSchema(schemaId, newOwner);
  }


  async getSchemasByIssuer(issuerDID: string): Promise<bigint[]> {
    return await this.contracts.schemaRegistry.getSchemasByIssuer(issuerDID);
  }

  async getSchemaIdByName(issuerDID: string, name: string): Promise<bigint> {
    return await this.contracts.schemaRegistry.getSchemaIdByName(issuerDID, name);
  }

  async getSchemasByType(schemaType: number): Promise<bigint[]> {
    return await this.contracts.schemaRegistry.getSchemasByType(schemaType);
  }

  async schemaExists(schemaId: number): Promise<boolean> {
    return await this.contracts.schemaRegistry.schemaExists(schemaId);
  }

  async getTotalSchemaCount(): Promise<bigint> {
    return await this.contracts.schemaRegistry.getTotalSchemaCount();
  }

  async getSchemaDependencies(schemaId: number): Promise<string[]> {
    return await this.contracts.schemaRegistry.getSchemaDependencies(schemaId);
  }

  async hasCircularDependencies(schemaId: number): Promise<boolean> {
    return await this.contracts.schemaRegistry.hasCircularDependencies(schemaId);
  }

  // Utility methods
  async getGasPrice(): Promise<bigint> {
    const feeData = await this.provider.getFeeData();
    return feeData.gasPrice || 0n;
  }

  async estimateGas(method: string, ...args: any[]): Promise<bigint> {
    // This would need to be implemented based on the specific method
    // For now, return a default estimate
    return 100000n;
  }

  async waitForTransaction(txHash: string): Promise<ethers.TransactionReceipt | null> {
    return await this.provider.waitForTransaction(txHash);
  }

  getAddress(): string | null {
    return this.signer?.address || null;
  }

  async getBalance(address?: string): Promise<bigint> {
    const addr = address || this.signer?.address;
    if (!addr) {
      throw new Error('No address provided and no signer available');
    }
    return await this.provider.getBalance(addr);
  }

  // Event listening
  onDIDRegistered(callback: (did: string, owner: string, publicKey: string, timestamp: bigint) => void) {
    this.contracts.didRegistry.on('DIDRegistered', callback);
  }

  onDIDUpdated(callback: (did: string, owner: string, newPublicKey: string, timestamp: bigint) => void) {
    this.contracts.didRegistry.on('DIDUpdated', callback);
  }

  onRevocationListPublished(callback: (issuerHash: string, issuerDID: string, version: bigint, revokedCount: bigint, merkleRoot: string, timestamp: bigint) => void) {
    this.contracts.revocationRegistry.on('RevocationListPublished', callback);
  }

  onCredentialRevoked(callback: (issuerHash: string, credentialHash: string, issuerDID: string, timestamp: bigint) => void) {
    this.contracts.revocationRegistry.on('CredentialRevoked', callback);
  }

  onSchemaRegistered(callback: (schemaId: bigint, issuerDID: string, name: string, version: string, schemaType: number, timestamp: bigint) => void) {
    this.contracts.schemaRegistry.on('SchemaRegistered', callback);
  }

  // Clean up event listeners
  removeAllListeners() {
    this.contracts.didRegistry.removeAllListeners();
    this.contracts.revocationRegistry.removeAllListeners();
    this.contracts.schemaRegistry.removeAllListeners();
  }

  // Query events
  async queryDIDEvents(filter: {
    owner?: string;
    fromBlock?: number | string;
    toBlock?: number | string;
  }): Promise<ethers.EventLog[]> {
    const eventFilter = this.contracts.didRegistry.filters.DIDRegistered();
    const events = await this.contracts.didRegistry.queryFilter(
      eventFilter,
      filter.fromBlock || 0,
      filter.toBlock || 'latest'
    );
    return events as ethers.EventLog[];
  }

  async querySchemaEvents(filter: {
    issuerDID?: string;
    fromBlock?: number | string;
    toBlock?: number | string;
  }): Promise<ethers.EventLog[]> {
    const eventFilter = filter.issuerDID
      ? this.contracts.schemaRegistry.filters.SchemaRegistered(null, filter.issuerDID)
      : this.contracts.schemaRegistry.filters.SchemaRegistered();
    
    const events = await this.contracts.schemaRegistry.queryFilter(
      eventFilter,
      filter.fromBlock || 0,
      filter.toBlock || 'latest'
    );
    return events as ethers.EventLog[];
  }

  async queryRevocationEvents(filter: {
    issuerDID?: string;
    fromBlock?: number | string;
    toBlock?: number | string;
  }): Promise<ethers.EventLog[]> {
    const eventFilter = filter.issuerDID
      ? this.contracts.revocationRegistry.filters.RevocationListPublished(null, filter.issuerDID)
      : this.contracts.revocationRegistry.filters.RevocationListPublished();
    
    const events = await this.contracts.revocationRegistry.queryFilter(
      eventFilter,
      filter.fromBlock || 0,
      filter.toBlock || 'latest'
    );
    return events as ethers.EventLog[];
  }

  // Additional helper methods for BlockchainStorageProvider
  async checkRevocation(issuerDID: string, credentialHash: string): Promise<boolean> {
    return await this.isCredentialRevokedByHash(
      ethers.keccak256(ethers.toUtf8Bytes(issuerDID)),
      credentialHash
    );
  }

  async getSchema(schemaIdOrName: string | number): Promise<any> {
    if (typeof schemaIdOrName === 'number') {
      return await this.contracts.schemaRegistry.getSchema(schemaIdOrName);
    }
    
    // Try to parse as schema:uuid format
    if (schemaIdOrName.startsWith('schema:')) {
      // This is a named schema, need to find it by querying events
      const events = await this.querySchemaEvents({
        fromBlock: 0,
        toBlock: 'latest'
      });
      
      for (const event of events) {
        const schemaId = event.args.schemaId;
        const schema = await this.contracts.schemaRegistry.getSchema(schemaId);
        if (schema.name === schemaIdOrName.substring(7)) {
          return schema;
        }
      }
    }
    
    return null;
  }
}